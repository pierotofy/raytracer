#!/usr/bin/ruby

# Piero Toffanin 2012 - http://www.pierotoffanin.com
# Note: only works on Unix based systems

# from <start> to <finish> [step n] <increase|decrease|set> <property>[-x|-y|-z] of <obj-id> by|at <value> 

require './Arguments'
require 'rubygems'
require 'xml'
require 'fileutils'
require 'pathname'

RAYTRACER_PATH="../build/raytracer"
PRECISION = 6

# Method to calculate the time left from current time based on an offset
def calculate_time_left(difference)
  calculated_time = {}
   
  #calculating the days, hours, minutes and seconds out of the initial large seconds value generated by 'difference', then dropping the values after the decimal
  calculated_time[:days] = (difference / (60*60*24)).to_i
  days_remainder = (difference % (60*60*24)).to_i
  calculated_time[:hours] = (days_remainder / (60*60)).to_i
  hours_remainder = (days_remainder % (60 * 60)).to_i
  calculated_time[:minutes] = (hours_remainder / 60).to_i
  calculated_time[:seconds] = (hours_remainder % 60).to_i
  calculated_time
end

def render_frame(t, total_time, width, height, rpp, threads, basedir, type, fps, output)
	t1 = Time.now
	puts "Rendering frame #{t}"
	flags = "-w #{width} -h #{height} -r #{rpp} -n #{threads} -i #{basedir}/frame_#{t}.xml -o #{basedir}/frames/frame_#{t}.png"
	flags = flags + " -3" if type == "3d"

	system("#{RAYTRACER_PATH} #{flags}")
	t2 = Time.now
	diff = t2 - t1
	time_left = calculate_time_left(diff * (total_time - t))
	puts "Frame #{t} rendered in #{(diff).round(4)}s - ETA #{time_left[:days]}d #{time_left[:hours]}h #{time_left[:minutes]}m #{time_left[:seconds]}s"
end

def render_frames(total_time, width, height, rpp, threads, basedir, type, fps, output)
	total_time.times do |t|
		render_frame(t, total_time, width, height, rpp, threads, basedir, type, fps, output)
	end

	combine_frames(fps, basedir, output)
end

def combine_frames(fps, basedir, output)
	system("ffmpeg -r #{fps} -sameq -i #{basedir}/frames/frame_%d.png #{output}")
end



if ARGV.length < 2
	puts "Usage: ./animator.rb <startSceneFile> <animationFile> [--width width] [--height height] [--rpp rpp] [--type type] [--numthreads numthreads] [--output filename] [--fps framespersecond] [--renderframes numframes] [--resume yes|no]"
	puts "	rpp: samples per pixels (default 1)"
	puts "	type: 3d | normal" 
	puts " 	fps: frames per second (default 30)"
	puts "	resume: if yes will render only those frames that haven't been rendered"
	exit
end

args = PTCommon::Arguments.new(
  {
  'width' => 200, #width
  'height' => 200, #height
  'rpp' => 1, #rpp
  'type' => "normal", #type
  'numthreads' => 1,
  'output' => "movie.mp4",
  'fps' => 30,
  'renderframes' => 0, # Skip scene files generation, render only!
  'resume' => "no"
  })

start_scene_file = ARGV[0]
animation_file = ARGV[1]
width = args.width
height = args.height
rpp = args.rpp
type = args.type
threads = args.numthreads
basedir = Pathname.new(start_scene_file).dirname

# Cleanup previous runs
system("rm -fr #{basedir}/frames")
system("rm #{basedir}/frame_*.xml")

# Create directory structure
system("mkdir #{basedir}/frames")

puts "======="
puts "startSceneFile: #{start_scene_file}"
puts "animationFile: #{animation_file}"
puts "Width: #{width}"
puts "height: #{height}"
puts "rpp: #{rpp}"
puts "type: #{type}"
puts "threads: #{threads}"
puts "output: #{args.output}"
puts "fps: #{args.fps}"
puts "resume: #{args.resume}"
puts "======="
# Read in original XML file
print "Parsing #{start_scene_file}... "
parser = XML::Parser.file(start_scene_file)
original_scene = parser.parse
puts "Done!"

line_regex = /^from (?<from>[\d]+) to (?<to>[\d]+) (step (?<step>[\d]+) )?(?<action>increase|decrease|set) (?<property>[\w_-]+) of (?<obj-id>[\w_-]+) (by|at) (?<expression>.+)$/
comment_regex = /^(#.*|)$/ # blank line also

linenum = 1
operations = []
total_time = 0 # max frame number
print "Parsing #{animation_file}... "
File.open(animation_file).each { |line|
	if comment_regex.match(line)
		linenum += 1
		next
	end

	values = line_regex.match(line);
	if values.nil?
		puts "Syntax error while parsing line #{linenum}:#{line}" 
		exit
	end

	# Comment or blank line?
	next if values['from'].nil?

	operation = {}

	# Convert
	['from', 'to'].each do |prop|
		operation[prop] = values[prop].to_i
	end
	operation['step'] = 1
	operation['step'] = values['step'].to_i unless values['step'].nil?
	operation['expression'] = values['expression']

	['action', 'obj-id'].each do |prop|
		operation[prop] = values[prop]
	end

	# Some property are expressed in terms of components (center-x, position-y, etc)
	# need to split the information in property/component
	if values['property'] =~ /([\w_]+)-([xyz])/
		operation['property'] = $1
		operation['component'] = $2
	else
		operation['property'] = values['property']
	end

	# Calculate frames interval
	operation['frames'] = (operation['from']..operation['to']).step(operation['step']).to_a
	operation['linenum'] = linenum

	operations << operation
	total_time = operation['to'] if total_time < operation['to']
   	linenum += 1
}
puts "Done!"

print "Generating scene files"
total_time.times do |t|
	# t = current time
	# scan each operation
	operations.each do |operation|
		# do we need to do something?
		if operation['frames'].include?(t) 

			# Find item in scene file
			node = original_scene.root.children.detect{ |n| n.attributes['name'] == operation['obj-id'] }
			
			if node.nil?
				puts "Parse error: unexisting item #{operation['obj-id']}"
				exit(0)
			end

			# Trasform?
			rotation = false
			if ['scale', 'translate'].include?(operation['property'])
				item = node.children.detect{ |item| item.name == 'transform' }.children.detect{ |item| item.name == operation['property'] }
			elsif operation['property'] == 'rotate'
				item = node.children.detect{ |item| item.name == 'transform' }.children.detect{ |item| item.name == operation['property'] && item['axis'] == operation['component'].upcase }
				rotation = true
			else
				item = node.children.detect{ |item| item.name == operation['property'] }
			end

			if item.nil? 
				puts "\nParse error: Could not find item #{operation['property']}-#{operation['component']} for #{operation['obj-id']} on line #{operation['linenum']}"
				exit
			end

			# get current property value
			current_value = item.content
			if !rotation && !operation['component'].nil?
				current_value = item.content.split(' ')[(case operation['component']
															when 'x'
																0
															when 'y'
																1
															when 'z'
																2
														end)]
			end

			if operation['action'] == 'increase'
				new_value = current_value.to_f + eval(operation['expression'])
			elsif operation['action'] == 'decrease'
				new_value = current_value.to_f - eval(operation['expression'])
			elsif operation['action'] == 'set'
				new_value = eval(operation['expression'])
			end

			# Set new value
			final_value = new_value.round(PRECISION)
			if !operation['component'].nil? && !rotation
				parts = item.content.split(' ')
				parts[(case operation['component']
							when 'x'
								0
							when 'y'
								1
							when 'z'
								2
						end)] = new_value.round(PRECISION)
				final_value = parts.join(' ')
			end

			# Save new scene file
			item.content = final_value.to_s
			original_scene.save("#{basedir}/frame_#{t}.xml")
		end
	end

	print '.'
end
puts " Done!"

# Run the ray tracer
total_time.times do |t|
	t1 = Time.now
	puts "Rendering frame #{t}"
	flags = "-w #{width} -h #{height} -r #{rpp} -n #{threads} -i #{basedir}/frame_#{t}.xml -o #{basedir}/frames/frame_#{t}.png"
	flags = flags + " -3" if type == "3d"

	system("#{RAYTRACER_PATH} #{flags}")
	t2 = Time.now
	diff = t2 - t1
	time_left = calculate_time_left(diff * (total_time - t))
	puts "Frame #{t} rendered in #{(diff).round(4)}s - ETA #{time_left[:days]}d #{time_left[:hours]}h #{time_left[:minutes]}m #{time_left[:seconds]}s"
end

# Combine frames
system("ffmpeg -r 30 -b 9600 -mbd rd -flags +mv4+aic -trellis 2 -cmp 2 -subcmp 2 -g 300 -pass 1/2 -i #{basedir}/frames/frame_%d.png #{args.output}")

puts "All done! Get some popcorn and enjoy."
